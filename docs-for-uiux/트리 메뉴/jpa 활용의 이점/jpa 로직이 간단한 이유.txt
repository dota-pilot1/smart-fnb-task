JPA 트리 조회 로직이 간단한 이유
==================================

핵심: 엔티티 = 데이터 + DB 연결 통로


1. MyBatis vs JPA 비교
------------------------

  MyBatis — Row를 가져옴 (단순 데이터)

    select * from dev_spec where parent_id is null
    → [{id:1, name:"프로젝트A", parent_id:null}]  // 데이터 끝
    → 자식? 별도 쿼리 + 직접 조립해야 함

    코드:
      List<DevSpec> all = mapper.selectAll();

      Map<Long, List<DevSpec>> grouped = all.stream()
          .filter(s -> s.getParentId() != null)
          .collect(Collectors.groupingBy(DevSpec::getParentId));

      List<DevSpec> roots = all.stream()
          .filter(s -> s.getParentId() == null)
          .peek(s -> s.setChildren(grouped.getOrDefault(s.getId(), List.of())))
          .toList();


  JPA — Row가 살아있는 객체가 됨

    ProjectDevSpec project = findById(1);
    // 단순 데이터가 아니라 DB와 연결된 객체

    project.getChildren()
    // JPA가 자동으로 쿼리 실행
    // → SELECT * FROM dev_spec WHERE parent_id = 1
    // → 결과도 살아있는 객체 리스트로 반환

    project.getChildren().get(0).getChildren()
    // → 또 자동 쿼리... 계속 타고 내려감

    코드:
      devSpecRepository
          .findByParentIsNull()
          .stream()
          .map(DevSpecTreeResponse::from)
          .toList();
      // 끝. 이게 전부.


2. 왜 이게 가능한가?
---------------------
  @OneToMany가 "사서 연결"을 해주기 때문.

    @OneToMany(mappedBy = "parent")
    private List<ProjectDevSpec> children;

  이 한 줄의 의미:
    "이 필드는 DB의 parent_id 외래키와 연결된 자식 목록이야"
    → getChildren() 호출하면 JPA가 알아서 쿼리 해줌

  비유:
    MyBatis = 도서관에서 책 복사본 받아옴
               관련 책 필요하면 다시 가서 직접 찾아야 함

    JPA     = 도서관 사서가 붙어있음
               "관련 책 뭐 있어?" 물어보면 알아서 가져다줌


3. 재귀 트리가 자동 완성되는 흐름
----------------------------------
  DevSpecTreeResponse.from() 메서드:

    public static DevSpecTreeResponse from(ProjectDevSpec entity) {
        return new DevSpecTreeResponse(
            entity.getName(),
            entity.getChildren().stream()     // ← 여기서 자동 쿼리
                .map(DevSpecTreeResponse::from) // ← 자식도 getChildren() → 또 자동 쿼리
                .toList()
        );
    }

  실행 흐름:
    1) 프로젝트A.getChildren() → JPA가 자식 [페이지1, 페이지2] 조회
    2) 페이지1.getChildren()   → JPA가 자식 조회 (없으면 빈 리스트)
    3) 페이지2.getChildren()   → 마찬가지
    → 객체를 타고 내려가기만 하면 트리가 완성됨


4. 정리
--------
  MyBatis: 데이터 조회 + 조립 로직 전부 개발자 몫
  JPA:     엔티티 관계 선언(@OneToMany) → 객체 탐색만 하면 자동 조회

  트리 구조 같은 자기 참조 관계에서는 JPA가 압도적으로 편함.
  코드량 차이: MyBatis 10줄+ vs JPA 3줄


5. 결국 이 한 줄이 되냐 안 되냐의 차이
-----------------------------------------

  JPA:
    spec.getChildren().stream()
        .map(DevSpecTreeResponse::from)   // ← 재귀 호출
        .toList()

    → spec.getChildren()이 DB 쿼리를 자동 실행
    → 자식 엔티티도 살아있는 객체 → 또 getChildren() 가능
    → 재귀가 자연스럽게 동작

  MyBatis:
    spec.getChildren()   // ← null 또는 빈 리스트. DB 연결이 없음.
    // 객체가 그냥 데이터 덩어리라서 자식을 알 방법이 없음
    // 그래서 직접 groupBy + 조립 코드를 짜야 함

  핵심:
    entity.getChildren()이 DB 쿼리를 자동 실행하느냐 아니냐
    이 한 가지 차이가 코드량 전체를 결정함
