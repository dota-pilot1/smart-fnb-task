컨트롤러 → 서비스 흐름 정리
==============================


1. 컨트롤러 (DevSpecController.java:28-30)
───────────────────────────────────────────
  @GetMapping("/projects")
  public ResponseEntity<List<DevSpecTreeResponse>> findAllProjects() {
      return ResponseEntity.ok(devSpecService.findAllProjects());
  }

  → 프론트가 GET /api/devspec/projects 요청
  → 서비스한테 넘김


2. 서비스 (DevSpecService.java:39-43)
───────────────────────────────────────────
  public List<DevSpecTreeResponse> findAllProjects() {
      return devSpecRepository.findByParentIsNull().stream()
              .map(DevSpecTreeResponse::from)
              .toList();
  }

  한 줄씩 역할:

    devSpecRepository.findByParentIsNull()  → DB에서 루트 노드 조회
                     .stream()              → 함수형 처리 준비
                     .map(DevSpecTreeResponse::from)  → ★ 트리 변환 (주요 로직)
                     .toList()              → 리스트로 변환


3. 주요 로직: DevSpecTreeResponse.from() (DevSpecTreeResponse.java:17)
───────────────────────────────────────────
  public static DevSpecTreeResponse from(ProjectDevSpec spec) {
      return new DevSpecTreeResponse(
          spec.getId(),
          spec.getName(),
          spec.getType(),
          spec.getStatus(),
          spec.getSortOrder(),
          spec.getDepth(),
          spec.getChildren().stream()        ← JPA가 자식 자동 로딩
              .map(DevSpecTreeResponse::from) ← 자기 자신 재귀 호출
              .toList()
      );
  }

  → 이 from() 하나가 "엔티티 → 트리 JSON" 변환의 전부
  → getChildren()에서 JPA가 SQL 날림 → 자식마다 from() 재귀
  → 자식이 없으면 빈 리스트 → 재귀 종료


========================================
FAQ
========================================

Q1. .stream()은 뭐야?
─────────────────────
  함수형 처리를 하기 위한 흐름(파이프라인)을 만드는 것.

  리스트가 [A, B, C] 라면:

    리스트.stream()     → A, B, C를 하나씩 꺼낼 준비
         .map(변환)     → 각각에 변환 함수 적용
         .toList()      → 결과를 다시 리스트로

  stream() 자체는 아무것도 안 함.
  "이제부터 .map() .filter() 같은 함수형 처리 할게" 라는 선언.

  비유: 컨베이어 벨트 전원 켜기. 물건(데이터)이 흘러갈 준비.


Q2. findByParentIsNull()은 뭐야?
─────────────────────────────────
  parent_id가 NULL인 행 = 최상위 루트 노드만 조회.

  Spring Data JPA의 네이밍 규칙으로 자동 생성되는 쿼리:
    메서드명: findBy  +  Parent  +  IsNull
    → 실행 SQL: SELECT * FROM project_dev_specs WHERE parent_id IS NULL

  DB 데이터:
    id=1  parent_id=null  ← 이것만 조회됨 (루트)
    id=2  parent_id=1     ← 조회 안 됨 (자식)
    id=3  parent_id=1     ← 조회 안 됨 (자식)

  왜 루트만 조회하면 되냐?
    → 자식은 JPA @OneToMany가 getChildren() 시점에 자동으로 가져오니까
    → 루트만 잡으면 나머지는 줄줄이 딸려옴


Q3. DevSpecTreeResponse::from 에서 :: 은 뭐야?
────────────────────────────────────────────────
  "메서드 레퍼런스" 라고 부름.
  뜻: "이 클래스의 이 메서드를 가리킨다"

  DevSpecTreeResponse::from
  ─────────────────── ────
  클래스명              메서드명

  원래 이렇게 써야 하는 걸:

    .map(spec -> DevSpecTreeResponse.from(spec))   // 람다식

  줄인 것:

    .map(DevSpecTreeResponse::from)                // 메서드 레퍼런스

  완전히 같은 코드. 그냥 축약 문법.

  풀어서 보면:
    [프로젝트A, 프로젝트B] 각각에 대해
    1번째: DevSpecTreeResponse.from(프로젝트A)  → 트리 JSON A
    2번째: DevSpecTreeResponse.from(프로젝트B)  → 트리 JSON B

  비유: :: = "이 공장(from)을 쓸 거야" 라고 가리키는 손가락
