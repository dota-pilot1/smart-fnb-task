# 트리 메뉴 생성 스킬

범용 트리 메뉴를 백엔드(Spring Boot + JPA) + 프론트엔드(React + TypeScript)로 생성한다.
사용자가 도메인명과 노드 타입을 알려주면, 아래 패턴에 맞춰 전체 코드를 생성한다.

## 사용자 입력 확인

아래 항목을 사용자에게 먼저 확인한다:

1. **엔티티명** (예: Category, Menu, Organization)
2. **노드 타입 종류** (예: FOLDER/FILE, DEPARTMENT/TEAM, CATEGORY/ITEM)
3. **노드 상태 종류** (예: ACTIVE/INACTIVE, TODO/IN_PROGRESS/DONE) — 필요 없으면 생략
4. **최대 깊이 제한** — 없으면 무제한
5. **백엔드 베이스 패키지** (예: com.smartfnb)
6. **API 베이스 경로** (예: /api/categories)

---

## 1. 백엔드 생성 패턴

### 1-1. 도메인 엔티티 (자기 참조 트리)

```java
@Entity
@Table(
    name = "{테이블명}",
    uniqueConstraints = @UniqueConstraint(columnNames = {"parent_id", "name"})
)
public class {엔티티명} {

    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, length = 100)
    private String name;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    private {엔티티명} parent;

    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    @OrderBy("sortOrder ASC")
    private List<{엔티티명}> children = new ArrayList<>();

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private {타입Enum} type;

    // 상태가 필요한 경우에만 포함
    @Enumerated(EnumType.STRING)
    private {상태Enum} status;

    @Column(nullable = false)
    private int sortOrder;

    @Column(nullable = false)
    private int depth;

    // 팩토리 메서드
    public static {엔티티명} createRoot(String name) {
        // type = 루트타입, depth = 0, parent = null
    }

    public static {엔티티명} createChild(String name, {엔티티명} parent, {타입Enum} type, int sortOrder) {
        // depth = parent.depth + 1
    }
}
```

핵심 포인트:
- parent_id + name 유니크 제약 (같은 부모 아래 이름 중복 방지)
- children은 CASCADE ALL + orphanRemoval (삭제 시 자식 자동 삭제)
- sortOrder로 형제 노드 간 정렬
- depth는 parent.depth + 1로 자동 계산

### 1-2. Repository

```java
public interface {엔티티명}Repository {
    List<{엔티티명}> findByParentIsNullOrderBySortOrderAsc();  // 루트 노드 조회
    Optional<{엔티티명}> findById(Long id);
    {엔티티명} save({엔티티명} entity);
    void deleteById(Long id);
}
```

### 1-3. 응답 DTO (재귀 구조)

```java
public record {엔티티명}TreeResponse(
    Long id,
    String name,
    {타입Enum} type,
    {상태Enum} status,    // 상태가 있는 경우
    int sortOrder,
    int depth,
    List<{엔티티명}TreeResponse> children
) {
    public static {엔티티명}TreeResponse from({엔티티명} entity) {
        return new {엔티티명}TreeResponse(
            entity.getId(),
            entity.getName(),
            entity.getType(),
            entity.getStatus(),
            entity.getSortOrder(),
            entity.getDepth(),
            entity.getChildren().stream()
                .map({엔티티명}TreeResponse::from)   // 재귀 변환
                .toList()
        );
    }
}
```

### 1-4. Service

```java
@Service
@Transactional(readOnly = true)
public class {엔티티명}Service {

    // 전체 트리 조회 (루트 + 재귀 자식)
    public List<{엔티티명}TreeResponse> findAll() {
        return repository.findByParentIsNullOrderBySortOrderAsc()
            .stream()
            .map({엔티티명}TreeResponse::from)
            .toList();
    }

    // 루트 노드 생성
    @Transactional
    public {엔티티명}TreeResponse createRoot(String name) {
        {엔티티명} root = {엔티티명}.createRoot(name);
        return {엔티티명}TreeResponse.from(repository.save(root));
    }

    // 자식 노드 생성
    @Transactional
    public {엔티티명}TreeResponse createChild(Long parentId, String name, {타입Enum} type) {
        {엔티티명} parent = repository.findById(parentId).orElseThrow();
        int nextOrder = parent.getChildren().size();
        {엔티티명} child = {엔티티명}.createChild(name, parent, type, nextOrder);
        repository.save(child);
        return {엔티티명}TreeResponse.from(parent);  // 부모 트리 반환
    }

    // 삭제 (cascade로 자식도 삭제)
    @Transactional
    public void delete(Long id) {
        repository.deleteById(id);
    }
}
```

### 1-5. Controller

```java
@RestController
@RequestMapping("{API 베이스 경로}")
public class {엔티티명}Controller {

    GET  /              → 전체 트리 목록
    POST /              → 루트 노드 생성
    POST /{id}/children → 자식 노드 생성
    PUT  /{id}/name     → 이름 변경
    PUT  /{id}/status   → 상태 변경 (상태가 있는 경우)
    DELETE /{id}        → 노드 삭제 (cascade)
}
```

---

## 2. 프론트엔드 생성 패턴

### 2-1. 타입 정의

```typescript
interface {엔티티명}Tree {
  id: number;
  name: string;
  type: "{타입1}" | "{타입2}";
  status?: "{상태1}" | "{상태2}";   // 상태가 있는 경우
  sortOrder: number;
  depth: number;
  children: {엔티티명}Tree[];       // 재귀 구조
}
```

### 2-2. 데이터 훅

```typescript
function use{엔티티명}Tree() {
  const [trees, setTrees] = useState<{엔티티명}Tree[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const fetch = async () => {
    setLoading(true);
    const res = await api.get("{API 베이스 경로}");
    setTrees(res.data);
    setLoading(false);
  };

  const createRoot = async (name: string) => { /* POST → refetch */ };
  const createChild = async (parentId: number, name: string) => { /* POST → refetch */ };
  const deleteNode = async (id: number) => { /* DELETE → refetch */ };
  const updateName = async (id: number, name: string) => { /* PUT → refetch */ };

  useEffect(() => { fetch(); }, []);

  return { trees, loading, error, createRoot, createChild, deleteNode, updateName, refresh: fetch };
}
```

### 2-3. 트리 컴포넌트 (재귀 렌더링)

```typescript
// 재귀적으로 노드를 렌더링하는 범용 패턴
function TreeNode({ node, depth, expanded, onToggle, onSelect, selectedId }) {
  const hasChildren = node.children.length > 0;
  const isExpanded = expanded.has(node.id);

  return (
    <>
      <div style={{ paddingLeft: depth * 20 }}>
        {hasChildren && <button onClick={() => onToggle(node.id)}>{isExpanded ? "▼" : "▶"}</button>}
        <span onClick={() => onSelect(node.id)}>{node.name}</span>
      </div>
      {isExpanded && node.children.map(child => (
        <TreeNode key={child.id} node={child} depth={depth + 1} ... />
      ))}
    </>
  );
}

function TreeMenu({ trees, onSelect, selectedId }) {
  const [expanded, setExpanded] = useState<Set<number>>(new Set());

  const toggle = (id: number) => {
    setExpanded(prev => {
      const next = new Set(prev);
      next.has(id) ? next.delete(id) : next.add(id);
      return next;
    });
  };

  return trees.map(tree => (
    <TreeNode key={tree.id} node={tree} depth={0} expanded={expanded}
              onToggle={toggle} onSelect={onSelect} selectedId={selectedId} />
  ));
}
```

핵심 포인트:
- expanded: Set<number>로 펼침/접힘 관리
- TreeNode가 자기 자신을 재귀 호출 → 깊이 무제한 대응
- depth * padding으로 들여쓰기
- 선택/편집/삭제 액션은 콜백으로 상위에 위임

### 2-4. 페이지 레이아웃 (2패널)

```
┌──────────────┬──────────────────────────┐
│  트리 패널    │  상세/콘텐츠 패널          │
│  (고정 너비)  │  (나머지 영역)            │
│              │                          │
│  TreeMenu    │  선택된 노드의 상세 정보    │
│  컴포넌트     │  편집 영역                │
└──────────────┴──────────────────────────┘
```

---

## 3. 적용 체크리스트

생성 시 아래를 순서대로 확인:

- [ ] 엔티티 + Enum 생성
- [ ] Repository 인터페이스 + JPA 구현체
- [ ] 재귀 응답 DTO (TreeResponse)
- [ ] Service (조회/생성/수정/삭제)
- [ ] Controller (REST API)
- [ ] 프론트 타입 정의
- [ ] 데이터 훅 (fetch + CRUD)
- [ ] 재귀 TreeNode 컴포넌트
- [ ] 펼침/접힘 + 선택 상태 관리
- [ ] 페이지 레이아웃 (트리 + 상세 패널)
- [ ] 인라인 편집/생성 (필요 시)
