피그마 디테일 페이지 - 사이드바 리사이즈 구현
=============================================

파일: smart-fnb-front/src/pages/figma-detail/FigmaDetailPage.tsx


1. 최종 방법: 마우스 드래그 직접 구현
--------------------------------------
CSS resize는 핸들이 너무 작고 커스터마이징 불가 → 폐기.
라이브러리는 2분할에는 과한 편 → 불필요.
마우스 이벤트 3개로 직접 구현이 가장 적합.


2. 시도했던 방법들 비교
------------------------
  (1) CSS resize: horizontal + direction: rtl
      - 장점: JS 코드 0줄
      - 단점: 핸들이 작고 안 보임, 디자인 커스텀 불가
      → 폐기

  (2) 라이브러리 (react-resizable-panels 등)
      - 장점: 다중 분할, 중첩 레이아웃에 강함
      - 단점: 2분할에는 과한 의존성
      → 불필요

  (3) 마우스 드래그 직접 구현 ← 최종 선택
      - 장점: 드래그 바 디자인 자유, 코드 간결
      - 단점: 없음 (2분할 기준)


3. 구현 원리
-------------
  상태:
    const [sideWidth, setSideWidth] = useState(320);   // 사이드바 너비
    const isResizing = useRef(false);                   // 드래그 중 여부

  이벤트 흐름:
    mousedown (드래그 바 클릭)
      → isResizing = true
      → body cursor를 col-resize로 변경
      → body userSelect를 none으로 (텍스트 선택 방지)

    mousemove (document 레벨)
      → isResizing가 true일 때만 동작
      → 새 너비 = window.innerWidth - e.clientX
      → 최소 200px, 최대 600px 범위 제한

    mouseup (document 레벨)
      → isResizing = false
      → cursor, userSelect 복원


4. 핵심 코드
-------------

  // --- state ---
  const [sideWidth, setSideWidth] = useState(320);
  const isResizing = useRef(false);

  // --- document 레벨 이벤트 (useEffect) ---
  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isResizing.current) return;
      const newWidth = window.innerWidth - e.clientX;
      setSideWidth(Math.min(600, Math.max(200, newWidth)));
    };

    const handleMouseUp = () => {
      isResizing.current = false;
      document.body.style.cursor = "";
      document.body.style.userSelect = "";
    };

    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    return () => {
      document.removeEventListener("mousemove", handleMouseMove);
      document.removeEventListener("mouseup", handleMouseUp);
    };
  }, []);

  // --- 드래그 시작 핸들러 ---
  const handleMouseDown = () => {
    isResizing.current = true;
    document.body.style.cursor = "col-resize";
    document.body.style.userSelect = "none";
  };

  // --- JSX 구조 ---
  <div className="flex flex-1 min-h-0">
    {/* 좌: iframe (flex-1로 나머지 영역 차지) */}
    <div className="flex-1">
      <iframe
        style={{ pointerEvents: isResizing.current ? "none" : "auto" }}
        ...
      />
    </div>

    {/* 드래그 바 (4px, hover 시 파란색) */}
    <div
      onMouseDown={handleMouseDown}
      className="w-1 bg-gray-200 hover:bg-blue-400 cursor-col-resize"
    />

    {/* 우: 사이드바 (너비를 state로 제어) */}
    <div style={{ width: sideWidth }}>
      ...체크리스트...
    </div>
  </div>


5. 주의 포인트
---------------
  Q. 드래그 중 iframe이 마우스 이벤트를 뺏는 문제?
  A. pointerEvents: "none"으로 드래그 중에는 iframe 비활성화.
     mouseup에서 복원됨.

  Q. 왜 useState가 아니라 useRef(isResizing)?
  A. mousemove는 초당 수십 회 발생.
     useRef는 리렌더 없이 값만 변경 → 성능 유리.
     setSideWidth만 state로 두면 필요한 리렌더만 발생.

  Q. 왜 mousemove/mouseup을 document에 등록?
  A. 드래그 바 밖으로 마우스가 벗어나도 계속 동작해야 하므로.
     드래그 바 자체에만 걸면 빠르게 움직일 때 끊김.


6. 너비 저장 (선택사항)
------------------------
현재는 저장 없이 구현.
나중에 필요하면 tanstack-store + localStorage로 너비 영속 가능.

7. 관련 파일
-------------
  smart-fnb-front/src/pages/figma-detail/FigmaDetailPage.tsx
    → 리사이즈 로직 전부 이 파일 하나에 구현됨
    → 드래그 state, 이벤트 핸들러, JSX 레이아웃 모두 포함

  smart-fnb-front/src/features/devspec/ui/ChecklistContent.tsx
    → 사이드바 안에 들어가는 체크리스트 컴포넌트
    → 리사이즈와 직접 관계 없음 (content/onSave만 받음)


8. 구조가 적절한가?
---------------------
  적절함. 이유:

  (1) 리사이즈는 FigmaDetailPage 전용 관심사
      - 이 페이지에서만 사용하는 레이아웃 로직
      - 별도 훅이나 컴포넌트로 분리할 필요 없음
      - 분리하면 오히려 파일만 늘어남

  (2) 코드량이 적음
      - state 2줄, useEffect 1개, 핸들러 1개
      - 커스텀 훅으로 뺄 정도가 아님

  (3) 분리가 필요해지는 시점
      - 다른 페이지에서도 동일한 리사이즈가 필요할 때
      → 그때 useResizable() 같은 훅으로 추출하면 됨
      → 현재는 YAGNI (You Aren't Gonna Need It)
